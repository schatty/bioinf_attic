BLOSUM62 = {
'A': {'A': 4, 'C': 0, 'E': -1, 'D': -2, 'G': 0, 'F': -2, 'I': -1, 'H': -2, 'K': -1, 'M': -1, 'L': -1, 'N': -2, 'Q': -1, 'P': -1, 'S': 1, 'R': -1, 'T': 0, 'W': -3, 'V': 0, 'Y': -2},
'C': {'A': 0, 'C': 9, 'E': -4, 'D': -3, 'G': -3, 'F': -2, 'I': -1, 'H': -3, 'K': -3, 'M': -1, 'L': -1, 'N': -3, 'Q': -3, 'P': -3, 'S': -1, 'R': -3, 'T': -1, 'W': -2, 'V': -1, 'Y': -2},
'E': {'A': -1, 'C': -4, 'E': 5, 'D': 2, 'G': -2, 'F': -3, 'I': -3, 'H': 0, 'K': 1, 'M': -2, 'L': -3, 'N': 0, 'Q': 2, 'P': -1, 'S': 0, 'R': 0, 'T': -1, 'W': -3, 'V': -2, 'Y': -2},
'D': {'A': -2, 'C': -3, 'E': 2, 'D': 6, 'G': -1, 'F': -3, 'I': -3, 'H': -1, 'K': -1, 'M': -3, 'L': -4, 'N': 1, 'Q': 0, 'P': -1, 'S': 0, 'R': -2, 'T': -1, 'W': -4, 'V': -3, 'Y': -3},
'G': {'A': 0, 'C': -3, 'E': -2, 'D': -1, 'G': 6, 'F': -3, 'I': -4, 'H': -2, 'K': -2, 'M': -3, 'L': -4, 'N': 0, 'Q': -2, 'P': -2, 'S': 0, 'R': -2, 'T': -2, 'W': -2, 'V': -3, 'Y': -3},
'F': {'A': -2, 'C': -2, 'E': -3, 'D': -3, 'G': -3, 'F': 6, 'I': 0, 'H': -1, 'K': -3, 'M': 0, 'L': 0, 'N': -3, 'Q': -3, 'P': -4, 'S': -2, 'R': -3, 'T': -2, 'W': 1, 'V': -1, 'Y': 3},
'I': {'A': -1, 'C': -1, 'E': -3, 'D': -3, 'G': -4, 'F': 0, 'I': 4, 'H': -3, 'K': -3, 'M': 1, 'L': 2, 'N': -3, 'Q': -3, 'P': -3, 'S': -2, 'R': -3, 'T': -1, 'W': -3, 'V': 3, 'Y': -1},
'H': {'A': -2, 'C': -3, 'E': 0, 'D': -1, 'G': -2, 'F': -1, 'I': -3, 'H': 8, 'K': -1, 'M': -2, 'L': -3, 'N': 1, 'Q': 0, 'P': -2, 'S': -1, 'R': 0, 'T': -2, 'W': -2, 'V': -3, 'Y': 2},
'K': {'A': -1, 'C': -3, 'E': 1, 'D': -1, 'G': -2, 'F': -3, 'I': -3, 'H': -1, 'K': 5, 'M': -1, 'L': -2, 'N': 0, 'Q': 1, 'P': -1, 'S': 0, 'R': 2, 'T': -1, 'W': -3, 'V': -2, 'Y': -2},
'M': {'A': -1, 'C': -1, 'E': -2, 'D': -3, 'G': -3, 'F': 0, 'I': 1, 'H': -2, 'K': -1, 'M': 5, 'L': 2, 'N': -2, 'Q': 0, 'P': -2, 'S': -1, 'R': -1, 'T': -1, 'W': -1, 'V': 1, 'Y': -1},
'L': {'A': -1, 'C': -1, 'E': -3, 'D': -4, 'G': -4, 'F': 0, 'I': 2, 'H': -3, 'K': -2, 'M': 2, 'L': 4, 'N': -3, 'Q': -2, 'P': -3, 'S': -2, 'R': -2, 'T': -1, 'W': -2, 'V': 1, 'Y': -1},
'N': {'A': -2, 'C': -3, 'E': 0, 'D': 1, 'G': 0, 'F': -3, 'I': -3, 'H': 1, 'K': 0, 'M': -2, 'L': -3, 'N': 6, 'Q': 0, 'P': -2, 'S': 1, 'R': 0, 'T': 0, 'W': -4, 'V': -3, 'Y': -2},
'Q': {'A': -1, 'C': -3, 'E': 2, 'D': 0, 'G': -2, 'F': -3, 'I': -3, 'H': 0, 'K': 1, 'M': 0, 'L': -2, 'N': 0, 'Q': 5, 'P': -1, 'S': 0, 'R': 1, 'T': -1, 'W': -2, 'V': -2, 'Y': -1},
'P': {'A': -1, 'C': -3, 'E': -1, 'D': -1, 'G': -2, 'F': -4, 'I': -3, 'H': -2, 'K': -1, 'M': -2, 'L': -3, 'N': -2, 'Q': -1, 'P': 7, 'S': -1, 'R': -2, 'T': -1, 'W': -4, 'V': -2, 'Y': -3},
'S': {'A': 1, 'C': -1, 'E': 0, 'D': 0, 'G': 0, 'F': -2, 'I': -2, 'H': -1, 'K': 0, 'M': -1, 'L': -2, 'N': 1, 'Q': 0, 'P': -1, 'S': 4, 'R': -1, 'T': 1, 'W': -3, 'V': -2, 'Y': -2},
'R': {'A': -1, 'C': -3, 'E': 0, 'D': -2, 'G': -2, 'F': -3, 'I': -3, 'H': 0, 'K': 2, 'M': -1, 'L': -2, 'N': 0, 'Q': 1, 'P': -2, 'S': -1, 'R': 5, 'T': -1, 'W': -3, 'V': -3, 'Y': -2},
'T': {'A': 0, 'C': -1, 'E': -1, 'D': -1, 'G': -2, 'F': -2, 'I': -1, 'H': -2, 'K': -1, 'M': -1, 'L': -1, 'N': 0, 'Q': -1, 'P': -1, 'S': 1, 'R': -1, 'T': 5, 'W': -2, 'V': 0, 'Y': -2},
'W': {'A': -3, 'C': -2, 'E': -3, 'D': -4, 'G': -2, 'F': 1, 'I': -3, 'H': -2, 'K': -3, 'M': -1, 'L': -2, 'N': -4, 'Q': -2, 'P': -4, 'S': -3, 'R': -3, 'T': -2, 'W': 11, 'V': -3, 'Y': 2},
'V': {'A': 0, 'C': -1, 'E': -2, 'D': -3, 'G': -3, 'F': -1, 'I': 3, 'H': -3, 'K': -2, 'M': 1, 'L': 1, 'N': -3, 'Q': -2, 'P': -2, 'S': -2, 'R': -3, 'T': 0, 'W': -3, 'V': 4, 'Y': -1},
'Y': {'A': -2, 'C': -2, 'E': -2, 'D': -3, 'G': -3, 'F': 3, 'I': -1, 'H': 2, 'K': -2, 'M': -1, 'L': -1, 'N': -2, 'Q': -1, 'P': -3, 'S': -2, 'R': -2, 'T': -2, 'W': 2, 'V': -1, 'Y': 7}}

Pam250 = {'A': {'A': 2, 'C': -2, 'E': 0, 'D': 0, 'G': 1, 'F': -3, 'I': -1, 'H': -1, 'K': -1, 'M': -1, 'L': -2, 'N': 0, 'Q': 0, 'P': 1, 'S': 1, 'R': -2, 'T': 1, 'W': -6, 'V': 0, 'Y': -3}, 'C': {'A': -2, 'C': 12, 'E': -5, 'D': -5, 'G': -3, 'F': -4, 'I': -2, 'H': -3, 'K': -5, 'M': -5, 'L': -6, 'N': -4, 'Q': -5, 'P': -3, 'S': 0, 'R': -4, 'T': -2, 'W': -8, 'V': -2, 'Y': 0}, 'E': {'A': 0, 'C': -5, 'E': 4, 'D': 3, 'G': 0, 'F': -5, 'I': -2, 'H': 1, 'K': 0, 'M': -2, 'L': -3, 'N': 1, 'Q': 2, 'P': -1, 'S': 0, 'R': -1, 'T': 0, 'W': -7, 'V': -2, 'Y': -4}, 'D': {'A': 0, 'C': -5, 'E': 3, 'D': 4, 'G': 1, 'F': -6, 'I': -2, 'H': 1, 'K': 0, 'M': -3, 'L': -4, 'N': 2, 'Q': 2, 'P': -1, 'S': 0, 'R': -1, 'T': 0, 'W': -7, 'V': -2, 'Y': -4}, 'G': {'A': 1, 'C': -3, 'E': 0, 'D': 1, 'G': 5, 'F': -5, 'I': -3, 'H': -2, 'K': -2, 'M': -3, 'L': -4, 'N': 0, 'Q': -1, 'P': 0, 'S': 1, 'R': -3, 'T': 0, 'W': -7, 'V': -1, 'Y': -5}, 'F': {'A': -3, 'C': -4, 'E': -5, 'D': -6, 'G': -5, 'F': 9, 'I': 1, 'H': -2, 'K': -5, 'M': 0, 'L': 2, 'N': -3, 'Q': -5, 'P': -5, 'S': -3, 'R': -4, 'T': -3, 'W': 0, 'V': -1, 'Y': 7}, 'I': {'A': -1, 'C': -2, 'E': -2, 'D': -2, 'G': -3, 'F': 1, 'I': 5, 'H': -2, 'K': -2, 'M': 2, 'L': 2, 'N': -2, 'Q': -2, 'P': -2, 'S': -1, 'R': -2, 'T': 0, 'W': -5, 'V': 4, 'Y': -1}, 'H': {'A': -1, 'C': -3, 'E': 1, 'D': 1, 'G': -2, 'F': -2, 'I': -2, 'H': 6, 'K': 0, 'M': -2, 'L': -2, 'N': 2, 'Q': 3, 'P': 0, 'S': -1, 'R': 2, 'T': -1, 'W': -3, 'V': -2, 'Y': 0}, 'K': {'A': -1, 'C': -5, 'E': 0, 'D': 0, 'G': -2, 'F': -5, 'I': -2, 'H': 0, 'K': 5, 'M': 0, 'L': -3, 'N': 1, 'Q': 1, 'P': -1, 'S': 0, 'R': 3, 'T': 0, 'W': -3, 'V': -2, 'Y': -4}, 'M': {'A': -1, 'C': -5, 'E': -2, 'D': -3, 'G': -3, 'F': 0, 'I': 2, 'H': -2, 'K': 0, 'M': 6, 'L': 4, 'N': -2, 'Q': -1, 'P': -2, 'S': -2, 'R': 0, 'T': -1, 'W': -4, 'V': 2, 'Y': -2}, 'L': {'A': -2, 'C': -6, 'E': -3, 'D': -4, 'G': -4, 'F': 2, 'I': 2, 'H': -2, 'K': -3, 'M': 4, 'L': 6, 'N': -3, 'Q': -2, 'P': -3, 'S': -3, 'R': -3, 'T': -2, 'W': -2, 'V': 2, 'Y': -1}, 'N': {'A': 0, 'C': -4, 'E': 1, 'D': 2, 'G': 0, 'F': -3, 'I': -2, 'H': 2, 'K': 1, 'M': -2, 'L': -3, 'N': 2, 'Q': 1, 'P': 0, 'S': 1, 'R': 0, 'T': 0, 'W': -4, 'V': -2, 'Y': -2}, 'Q': {'A': 0, 'C': -5, 'E': 2, 'D': 2, 'G': -1, 'F': -5, 'I': -2, 'H': 3, 'K': 1, 'M': -1, 'L': -2, 'N': 1, 'Q': 4, 'P': 0, 'S': -1, 'R': 1, 'T': -1, 'W': -5, 'V': -2, 'Y': -4}, 'P': {'A': 1, 'C': -3, 'E': -1, 'D': -1, 'G': 0, 'F': -5, 'I': -2, 'H': 0, 'K': -1, 'M': -2, 'L': -3, 'N': 0, 'Q': 0, 'P': 6, 'S': 1, 'R': 0, 'T': 0, 'W': -6, 'V': -1, 'Y': -5}, 'S': {'A': 1, 'C': 0, 'E': 0, 'D': 0, 'G': 1, 'F': -3, 'I': -1, 'H': -1, 'K': 0, 'M': -2, 'L': -3, 'N': 1, 'Q': -1, 'P': 1, 'S': 2, 'R': 0, 'T': 1, 'W': -2, 'V': -1, 'Y': -3}, 'R': {'A': -2, 'C': -4, 'E': -1, 'D': -1, 'G': -3, 'F': -4, 'I': -2, 'H': 2, 'K': 3, 'M': 0, 'L': -3, 'N': 0, 'Q': 1, 'P': 0, 'S': 0, 'R': 6, 'T': -1, 'W': 2, 'V': -2, 'Y': -4}, 'T': {'A': 1, 'C': -2, 'E': 0, 'D': 0, 'G': 0, 'F': -3, 'I': 0, 'H': -1, 'K': 0, 'M': -1, 'L': -2, 'N': 0, 'Q': -1, 'P': 0, 'S': 1, 'R': -1, 'T': 3, 'W': -5, 'V': 0, 'Y': -3}, 'W': {'A': -6, 'C': -8, 'E': -7, 'D': -7, 'G': -7, 'F': 0, 'I': -5, 'H': -3, 'K': -3, 'M': -4, 'L': -2, 'N': -4, 'Q': -5, 'P': -6, 'S': -2, 'R': 2, 'T': -5, 'W': 17, 'V': -6, 'Y': 0}, 'V': {'A': 0, 'C': -2, 'E': -2, 'D': -2, 'G': -1, 'F': -1, 'I': 4, 'H': -2, 'K': -2, 'M': 2, 'L': 2, 'N': -2, 'Q': -2, 'P': -1, 'S': -1, 'R': -2, 'T': 0, 'W': -6, 'V': 4, 'Y': -2}, 'Y': {'A': -3, 'C': 0, 'E': -4, 'D': -4, 'G': -5, 'F': 7, 'I': -1, 'H': 0, 'K': -4, 'M': -2, 'L': -1, 'N': -2, 'Q': -4, 'P': -5, 'S': -3, 'R': -4, 'T': -3, 'W': 0, 'V': -2, 'Y': 10}}

def lsc_backtrack(v, w):
    s = [[0] * (len(w)+1) for _ in range(len(v)+1)]
    backtrack = [[None] * (len(w)+1) for _ in range(len(v)+1)]
    for i in range(len(v) + 1):
        s[i][0] = 0
    for j in range(len(w) + 1):
        s[0][j] = 0
    for i in range(1, len(v)+1):
        for j in range(1, len(w)+1):
            s[i][j] = max(s[i-1][j], s[i][j-1])
            if v[i-1] == w[j-1]:
                s[i][j] = max(s[i][j], s[i-1][j-1] + 1)
            if s[i][j] == s[i-1][j]:
                backtrack[i][j] = "↓"
            elif s[i][j] == s[i][j-1]:
                backtrack[i][j] = "→"
            elif s[i][j] == s[i-1][j-1]+1 and v[i-1] == w[j-1]:
                backtrack[i][j] = "↘"
    return backtrack


def output_lcs(backtrack, v, w, i, j):
    w_trace = []
    v_trace = []
    while True:
        if i == 0 or j == 0:
            break
        if backtrack[i][j] == '↓':
            v_trace.append(v[i-1])
            w_trace.append('-')
            i -= 1
        elif backtrack[i][j] == '→':
            w_trace.append(w[j-1])
            v_trace.append('-')
            j -= 1
        else:
            v_trace.append(v[i-1])
            w_trace.append(w[j-1])
            i -= 1
            j -= 1
    # Start of the strings
    if i == 0 and j != 0:
        w_trace.append(w[j-1])
        v_trace.append('-')
    elif j == 0 and i != 0:
        v_trace.append(v[i-1])
        w_trace.append('-')

    v_res = ''.join(reversed(v_trace))
    w_res = ''.join(reversed(w_trace))
    print("V: ", v_res)
    print("W: ", w_res)
    return v_res, w_res


def global_alignment(v, w):
    sigma = 5
    s = [[0] * (len(w)+1) for _ in range(len(v)+1)]
    backtrack = [['~'] * (len(w)+1) for _ in range(len(v)+1)]
    for j in range(1, len(w)+1):
        s[0][j]= s[0][j-1] - sigma
    for i in range(1, len(v)+1):
        s[i][0] = s[i-1][0] - sigma

    for i in range(1, len(v)+1):
        for j in range(1, len(w)+1):
            match_score = BLOSUM62[v[i-1]][w[j-1]]
            s[i][j] = max(s[i-1][j] - sigma, s[i][j-1] - sigma, s[i-1][j-1]+match_score)

            if s[i][j] == s[i-1][j] - sigma:
                backtrack[i][j] = "↓"
            elif s[i][j] == s[i][j-1] - sigma:
                backtrack[i][j] = "→"
            else:
                backtrack[i][j] = "↘"

    v_res, w_res = output_lcs(backtrack, v, w, len(v), len(w))
    return v_res, w_res, s[-1][-1]


def global_alignment_with_identity(v, w):
    sigma = 1
    s = [[0] * (len(w)+1) for _ in range(len(v)+1)]
    backtrack = [['~'] * (len(w)+1) for _ in range(len(v)+1)]
    for j in range(1, len(w)+1):
        s[0][j]= s[0][j-1] - sigma
    for i in range(1, len(v)+1):
        s[i][0] = s[i-1][0] - sigma

    for i in range(1, len(v)+1):
        for j in range(1, len(w)+1):
            if v[i-1] == w[j-1]:
                match_score = 0
            else:
                match_score = -1
            s[i][j] = max(s[i-1][j] - sigma, s[i][j-1] - sigma, s[i-1][j-1]+match_score)

            if s[i][j] == s[i-1][j] - sigma:
                backtrack[i][j] = "↓"
            elif s[i][j] == s[i][j-1] - sigma:
                backtrack[i][j] = "→"
            else:
                backtrack[i][j] = "↘"

    v_res, w_res = output_lcs(backtrack, v, w, len(v), len(w))
    return v_res, w_res, s[-1][-1]


def output_lcs_local(backtrack, s, v, w, i, j):
    w_trace = []
    v_trace = []
    while True:
        if i == 0 or j == 0:
            break
        if s[i][j] == 0:
            break
        if backtrack[i][j] == '↓':
            v_trace.append(v[i-1])
            w_trace.append('-')
            i -= 1
        elif backtrack[i][j] == '→':
            w_trace.append(w[j-1])
            v_trace.append('-')
            j -= 1
        else:
            v_trace.append(v[i-1])
            w_trace.append(w[j-1])
            i -= 1
            j -= 1
    # Start of the strings
    if i == 0 and j != 0:
        w_trace.append(w[j-1])
        v_trace.append('-')
    elif j == 0 and i != 0:
        v_trace.append(v[i-1])
        w_trace.append('-')

    v_res = ''.join(reversed(v_trace))
    w_res = ''.join(reversed(w_trace))
    print("V: ", v_res)
    print("W: ", w_res)
    return v_res, w_res


def local_alignment(v, w):
    sigma = 5
    s = [[0] * (len(w)+1) for _ in range(len(v)+1)]
    backtrack = [['~'] * (len(w)+1) for _ in range(len(v)+1)]
    for j in range(1, len(w)+1):
        s[0][j]= s[0][j-1] - sigma
    for i in range(1, len(v)+1):
        s[i][0] = s[i-1][0] - sigma

    for i in range(1, len(v)+1):
        for j in range(1, len(w)+1):
            match_score = Pam250[v[i-1]][w[j-1]]
            s[i][j] = max(s[i-1][j] - sigma, s[i][j-1] - sigma, s[i-1][j-1]+match_score, 0)
            if s[i][j] == s[i-1][j] - sigma:
                backtrack[i][j] = "↓"
            elif s[i][j] == s[i][j-1] - sigma:
                backtrack[i][j] = "→"
            elif s[i][j] == 0:
                backtrack[i][j] = 'taxi'
            else:
                backtrack[i][j] = "↘"

    max_score = max([max(a) for a in s])
    end_point = (0, 0)
    for i in range(len(s)):
        for j in range(len(s[0])):
            if s[i][j] == max_score:
                end_point = (i, j)
                break
    v_res, w_res = output_lcs_local(backtrack, s, v, w, end_point[0], end_point[1])
    return v_res, w_res, max_score


def fitting_alignment(v, w):

    def output_lcs_fitting(backtrack, v, w, i, j):
        w_trace = []
        v_trace = []
        while True:
            if i == 0 or j == 0:
                break
            if backtrack[i][j] == '↓':
                v_trace.append(v[i-1])
                w_trace.append('-')
                i -= 1
            elif backtrack[i][j] == '→':
                w_trace.append(w[j-1])
                v_trace.append('-')
                j -= 1
            else:
                v_trace.append(v[i-1])
                w_trace.append(w[j-1])
                i -= 1
                j -= 1

        if j != 0:
            w_trace.append(w[j-1])
            v_trace.append('-')

        v_res = ''.join(reversed(v_trace))
        w_res = ''.join(reversed(w_trace))
        print("V: ", v_res)
        print("W: ", w_res)
        return v_res, w_res

    sigma = 1
    s = [[0] * (len(w)+1) for _ in range(len(v)+1)]
    backtrack = [['~'] * (len(w)+1) for _ in range(len(v)+1)]
    for j in range(1, len(w)+1):
        s[0][j]= s[0][j-1] - sigma
    for i in range(1, len(v)+1):
        s[i][0] = s[i-1][0]# - sigma

    for i in range(1, len(v)+1):
        for j in range(1, len(w)+1):
            if v[i-1] == w[j-1]:
                match_score = 1
            else:
                match_score = -1
            if j == 1:
                s[i][j] = max(s[i-1][j] - sigma, s[i][j-1] - sigma, s[i-1][j-1]+match_score, 0)
            else:
                s[i][j] = max(s[i-1][j] - sigma, s[i][j-1] - sigma, s[i-1][j-1]+match_score)

            if s[i][j] == s[i-1][j] - sigma:
                backtrack[i][j] = "↓"
            elif s[i][j] == s[i][j-1] - sigma:
                backtrack[i][j] = "→"
            elif s[i][j] == s[i][j-1] and j <= 1:
                backtrack[i][j] = "→"
            elif s[i][j] == 0:
                backtrack[i][j] = '→'
            else:
                backtrack[i][j] = "↘"

    max_sc = -1e10
    max_ind = 0
    for i in range(len(s)):
        if s[i][-1] > max_sc:
            max_sc = s[i][-1]
            max_ind = i
        #print(s[i][-1])
    v_res, w_res = output_lcs_fitting(backtrack, v, w, max_ind, len(w))
    return v_res, w_res, max_sc


def overlapping_alignment(v, w):

    def output_lcs_overlap(backtrack, v, w, i, j):
        w_trace = []
        v_trace = []
        while True:
            if i == 0 or j == 0:
                break
            if backtrack[i][j] == '↓':
                v_trace.append(v[i-1])
                w_trace.append('-')
                i -= 1
            elif backtrack[i][j] == '→':
                w_trace.append(w[j-1])
                v_trace.append('-')
                j -= 1
            else:
                v_trace.append(v[i-1])
                w_trace.append(w[j-1])
                i -= 1
                j -= 1

        print("i, j", i, j)
        if j != 0:
            w_trace.append(w[j-1])
            v_trace.append('-')

        v_res = ''.join(reversed(v_trace))
        w_res = ''.join(reversed(w_trace))
        return v_res, w_res

    sigma = 2
    s = [[0] * (len(w)+1) for _ in range(len(v)+1)]
    backtrack = [['~'] * (len(w)+1) for _ in range(len(v)+1)]
    for j in range(1, len(w)+1):
        s[0][j]= s[0][j-1] - sigma
    for i in range(1, len(v)+1):
        s[i][0] = s[i-1][0]

    for i in range(1, len(v)+1):
        for j in range(1, len(w)+1):
            if v[i-1] == w[j-1]:
                match_score = 1
            else:
                match_score = -2
            if j == 1:
                s[i][j] = max(s[i-1][j] - sigma, s[i-1][j-1]+match_score, 0)
            else:
                s[i][j] = max(s[i-1][j] - sigma, s[i][j-1] - sigma, s[i-1][j-1]+match_score)

            if s[i][j] == s[i-1][j] - sigma:
                backtrack[i][j] = "↓"
            elif s[i][j] == s[i][j-1] - sigma:
                backtrack[i][j] = "→"
            elif s[i][j] == 0 and j == 1:
                backtrack[i][j] = '→'
            else:
                backtrack[i][j] = "↘"

    max_sc = max(s[-1])
    max_ind = len(s[-1]) - s[-1][::-1].index(max_sc) - 1
    v_res, w_res = output_lcs_overlap(backtrack, v, w, len(v), max_ind)
    return v_res, w_res, max_sc


if __name__ == "__main__":
    # (1) Global alignment problem
    s1 = 'PLEASANTLY'
    s2 = 'MEANLY'
    score = global_alignment(s1, s2)
    print(score)

    # (2) Local alignment problem
    s1 = 'MEANLY'
    s2 = 'PENALTY'
    score = local_alignment(s1, s2)
    print(score)

    # (3) Edit distance
    s1 = 'KRWGVCHYRADHSDQFNKCYNRYYYTRCIKSPPWNYHCPDWDYFMMNQAVQRTSKRTLVGTYSYEYPCMFEDKIAVETGPLQCERTYEDDGSNAQPMGQGMCVDMFLPEFSQLVIPIACTMNNNQYQYMLRVRTGMMCGFEFFNTRTAASPAEYTCQWVHVIVHRRLCCKPDILDTANYGMAEDICQRYELIINDLIWDAWHRPTIYASFPAYRKGCQLRGSSPWFVEDEILQGLDTYEFKLQHDVLCVPLRMEYWRKMMYMTDKTREDLCSDPIWGVKLGVSSYAMTHVVKHDFRNPQKACPHQWYRWWKGVWQMFCYEEKACNHERHMCGIRQTNLDARFVTFSSTNNQEMTNHKPSLPWYRMRECVDGNWITGVEWESRYWWKNVGNNHNVTFTWPAFSNTKQPIWVDVASSVEDVLIRYQYACTPLSKSSNKVHTTLPFPATAPCVKFMFSTPAIFVFKDVAWVTMVTPWELFPMAAPMDWNASNTMVGFAELVANWSMKQDWESNYQLTFSWPMFVKLDNMNHFQCGGGHGDNYWFEARNPERKETDRAAVLCWCAPDYEQQHSCSMVSLWNRGLQNTTSFAHQRFQNPMHSWRMLCNQIAHFINVAINNRREAKHSKIWRASVFDRQWLSFNMKQSWTIQMTLAHHTYMNKYVDKWEIDPERVHWYVWVSCIDAGWRVIKCSRGYDMKNMQYNHTWWTNTAYTVFDIMTCIQDTVFFKTHWHWVIKMGHYDKAYYHDSKRTWWGPIWGDIPDISETKNILCNIFCMCTAWCNCRDNMKQKQRGMMLWPNAVPIKPTEMWNTAKNGDQCSKCSDQYWNTYHDSDYGRCGDWDIKHT'
    s2 = 'KRWGFHHERWLIRKCYYYTRCKSDYFMINDAVRTLVKEPIETYSYEYPCMFEDKIAVETGPLQCEATYEDQGSNAQPMGQGNLCLTVVYNVDMFLPLVIPIACTRVREAVHAMCGFEFFASYAEYTWDHVIVHRRLCCKPYILDTSFLANRGIAEDICQRYELIIAWHRSFPAYRKGCQLRGTWCRSMRHILTGNSCEWTECLDTWIKKMYMTDNTPWEGACMYLFWGVKLHLWSYEKGPDGNYAHYGVGMVRCSVKHDFRNPKKAIHIPAHYVYRWWKGVWQMFCYYEKACNHECEHHMCGIRQTNLLQLTYKNPTFNRFVTFSSTNNQHCARMNCVMTNHKPSLPWYRMRECVDGNWITGVEWNSRYWWKNVNVTFTLGKAWKPAFSNTKQPIWVDVASDYFPCIRYQYANKVSVRVWNLTMLPFPATAPCVKFMFSTRAIAVFKDVAWVIMKTPWELFPMGAPMDWNASNTMVGFQELGANWSMKQESNYQLTPMFVNYWCSEANSCGRKEVWTHACAPDYEQQHSCSMVSLWNRGLKNTTSFAHQAFQNPMHTHEIVPELFINARREAKHSKPPIIRASVRQKKGPVLSFNQKQSWTINMVLATHTDKKEIDPERVHRYVWVSCIDCTISREGWRAIKEKQKNCSRGYDMWNMQYAHWWWTNTAYTELVFDIFKTHWHWVLKRHSSFQMVHYDKAYYHWGPIWIDIPDISETKNILCNIASHDKCMMTYKPNSSPLWPPMKDKQKRHTADPNPCSRDGCVIRIKPTNMWNTAKNGDQCSKCSDQYWNTYHDEVYGRCGDWDIKARQQGLYIMT'
    v, w, score = global_alignment_with_identity(s1, s2)
    s = 0
    for i in range(len(v)):
        if (v[i] != w[i]) or (v[i] == '-' and w[i] == '-'):
            s+= 1
    print(s)

    # (4) Fitting alignment
    v = 'GTAGGCTTAAGGTTA'
    w = 'TAGATA'
    score, v_al, w_al = fitting_alignment(v, w)
    print(score)
    print(v_al)
    print(w_al)

    # (5) Overlapping alignment
    v = 'PAWHEAE'
    w = 'HEAGAWGHEE'
    score, v_al, w_al = overlapping_alignment(v, w)
    print(score)
    print(v_al)
    print(w_al)
